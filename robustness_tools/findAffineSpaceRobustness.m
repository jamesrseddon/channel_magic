% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.
% 
%
%  Copyright Â© 2019 James R. Seddon
%  This file is part of project: Channel Magic
%
function [results, max_robustness_lower, max_robustness_upper] = ...
    findAffineSpaceRobustness(unitary,affine_spaces,A_mat,varargin)
%%% This function is intended to find the robustness generated by a
%%% unitary over a set of input stabiliser states, specified by a cell
%%% array listing affine spaces. This is for use in the case where the
%%% unitary is diagonal, as in this case all input stabiliser states
%%% associated with the same affine space will result in the same
%%% robustness. This is not the case for general unitaries. We deal with
%%% the case where the system consists of n qubits.
%%% A_mat is the matrix used in the CVX algorithm to find the optimal
%%% decomposition among stabiliser states.
%%% If varargin = 'high', this will be passed through to findRobustness(),
%%% which will tell CVX to look for a high precision solution.

%%% INITIALISATION AND ERROR-CHECKING
precision = 'normal';
solver = 'sedumi';

if nargin > 3
    precision = varargin{1};
end

if nargin > 4
    solver = varargin{2};
end

[U_dim,U_columns] = size(unitary);
U_num_qubits = log2(U_dim);

if ~(U_dim == U_columns)
    msg='Input unitary not square.';
    error(msg);
end

tolerance = 1e-10;
id_check = unitary'*unitary;
id_diff = id_check - eye(U_dim);
sum_diffs = sum(sum(abs(id_diff)))

if sum_diffs > tolerance
    msg = 'Input matrix is not unitary';
    error(msg);
end

sub_dimension_rows = size(affine_spaces,1);
results = {'subspace dimension' 'subspace index' 'affine space index'...
            'R upper bound' 'R lower bound'};
% Cycle over the rows in the cell array, where each row gives all affine
% spaces of dimension k.
for kk = 1:sub_dimension_rows
    current_row = affine_spaces(kk,:);
    
    current_dim = current_row{1};
    
    affine_space_array = current_row{4};
    number_subspaces = current_row{5};
    number_affine_spaces = current_row{6};
    
    
    
    % Cycle over subspaces of dimension current_dim.
    for subspace_index = 1:number_subspaces
        % Cycle over affine spaces deriving from current subspace.
        for affine_index = 1:number_affine_spaces
            current_affine_space = affine_space_array(:,:,...
                                                        affine_index,...
                                                        subspace_index);
            display(['Affine space ' num2str(affine_index)...
                        ' of subspace ' num2str(subspace_index)...
                        ' with dimension ' num2str(current_dim)...
                        ' is:']);
            current_affine_space
            
            % make a ket vector from the current affine space, then convert
            % it into a density matrix.
            state_vector = stateFromAffine(current_affine_space);
            state_rho = state_vector*state_vector';
            output_state_rho = unitary*state_vector*state_vector'*unitary';
            [l1norm,status,distribution,dual_var,...
                optbnd] =findRobustness(output_state_rho,A_mat,...
                                                precision,solver);
            display(['Robustness is ' num2str(l1norm) '.']);
            result_row = { current_dim subspace_index affine_index...
                            l1norm, optbnd};
            results = [results; result_row];
        end
    end
end

%%% COLLATE RESULTS AND OUTPUT
robustness_lower = cell2mat(results(2:end,5));
robustness_upper = cell2mat(results(2:end,4));

[max_robustness_upper, max_index] = max(robustness_upper);
max_robustness_lower = robustness_lower(max_index);


output = results;